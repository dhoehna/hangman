
==================== FINAL INTERFACE ====================
2017-11-14 07:33:33.4061574 UTC

interface main@main:Main 8002
  interface hash: 3079f30d9f2f73816fa83acbf32dc950
  ABI hash: 2c00b4f2d772abd88c6d6635c29b8db9
  export-list hash: 107462c649d23f7a1424a779e2f31ae1
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 7acef23fd9133795de92ef7f815fb164
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.allWords
  Main.alreadyGuessed
  Main.bindRandomWords
  Main.charInWord
  Main.fillInCharacter
  Main.freshPuzzle
  Main.gameOver
  Main.gameWin
  Main.gameWords
  Main.handleGuess
  Main.main
  Main.maiximumWordLength
  Main.mininumWordLength
  Main.randomWord
  Main.randomWord'
  Main.renderPuzzleChar
  Main.runGame
  Main.Puzzle{Main.Puzzle}
  Main.WordList
module dependencies:
package dependencies: Win32-2.3.1.1@Win32-2.3.1.1
                      array-0.5.1.1@array-0.5.1.1 base-4.9.1.0*
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1 random-1.1@random-1.1-9tceXaeYIMZ4JrKq20Egog*
                      time-1.6.0.1@time-1.6.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         time-1.6.0.1@time-1.6.0.1:Data.Time.Calendar.Gregorian
         time-1.6.0.1@time-1.6.0.1:Data.Time.Format.Parse
         time-1.6.0.1@time-1.6.0.1:Data.Time.LocalTime.LocalTime
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Control.Monad f915f187cea611986ebb12dbc69279ab
import  -/  base-4.9.1.0:Data.Char c49b58282af11503cc838e1052cf6b83
import  -/  base-4.9.1.0:Data.Foldable 254e836c2d813d34e47feb29bb8d40ed
import  -/  base-4.9.1.0:Data.List 7349774f430841349c90dfd1144aea97
import  -/  base-4.9.1.0:Data.Maybe ecf0c6f81372d9b58b142d5e758ea51b
import  -/  base-4.9.1.0:Data.OldList c9282ee91951bdcbd918d2960562c007
import  -/  base-4.9.1.0:GHC.Base 4caea1123ecf4b46e27cbccd6d279377
import  -/  base-4.9.1.0:GHC.List d11eb227c1c6fbfd89bb781d72eaea0d
import  -/  base-4.9.1.0:GHC.Num 38b8aac8807c096c7f3ca3c1eff02939
import  -/  base-4.9.1.0:GHC.Show eca5834daba3b6a2bbbe64ab52056707
import  -/  base-4.9.1.0:GHC.Unicode 7b64ed854a326c2c5bb224f237ed4a0b
import  -/  base-4.9.1.0:Prelude 74b3e204395920329f6de9d97206abe9
import  -/  base-4.9.1.0:System.Exit c7285b50307ae5b742cc92ebeb7b2666
import  -/  base-4.9.1.0:System.IO 5daf3f384209c11d9566e3409af8ec5d
import  -/  ghc-prim-0.5.0.0:GHC.Classes 16d48e012d23eaef9bca91ccdd572c02
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
import  -/  random-1.1@random-1.1-9tceXaeYIMZ4JrKq20Egog:System.Random 4c90117f915e12291e0c5f588320bf66
6045922ab9be9efcda54c9c5bf0b5016
  $fShowPuzzle :: GHC.Show.Show Main.Puzzle
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.Puzzle
                  Main.$fShowPuzzle_$cshowsPrec
                  Main.$fShowPuzzle_$cshow
                  Main.$fShowPuzzle_$cshowList -}
6045922ab9be9efcda54c9c5bf0b5016
  $fShowPuzzle1 :: Main.Puzzle -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (\ (x :: Main.Puzzle) (s :: GHC.Base.String)[OneShot] ->
                 case x of ww { Main.Puzzle ww1 ww2 ww3 ->
                 GHC.Base.++ @ GHC.Types.Char (Main.$w$cshow ww2 ww3) s }) -}
af8b2509c8f6218cd97ea6d88fc91f93
  $fShowPuzzle2 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# ' '#) -}
5ddbb80218b55189833ce5a44fbe1a1e
  $fShowPuzzle3 :: (GHC.Types.Char -> b -> b) -> b -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U>,
     Unfolding: (\ @ b
                   (c :: GHC.Types.Char -> b -> b)[OneShot]
                   (n :: b)[OneShot] ->
                 GHC.CString.unpackFoldrCString# @ b " Guessed so far: "# c n) -}
6045922ab9be9efcda54c9c5bf0b5016
  $fShowPuzzle_$cshow :: Main.Puzzle -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Main.Puzzle) ->
                 case w of ww { Main.Puzzle ww1 ww2 ww3 ->
                 Main.$w$cshow ww2 ww3 }) -}
6045922ab9be9efcda54c9c5bf0b5016
  $fShowPuzzle_$cshowList :: [Main.Puzzle] -> GHC.Show.ShowS
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ls :: [Main.Puzzle]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ Main.Puzzle Main.$fShowPuzzle1 ls s) -}
6045922ab9be9efcda54c9c5bf0b5016
  $fShowPuzzle_$cshowsPrec ::
    GHC.Types.Int -> Main.Puzzle -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,A><S(LSL),1*U(A,1*U,U)><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (x :: Main.Puzzle)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Main.$fShowPuzzle_$cshow x))
                   s) -}
563a88b7bd78be50ca7e48e1c689e5f3
  $tc'Puzzle :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3355915762698541313##
                   14556823112734747473##
                   Main.$trModule
                   Main.$tc'Puzzle1) -}
de85fd3ec53835ea43a4aa38197e049a
  $tc'Puzzle1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Puzzle"#) -}
dd3dad1a8e7d6ea0185c41d0f418859f
  $tcPuzzle :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4184397067194358297##
                   5931153594655639713##
                   Main.$trModule
                   Main.$tcPuzzle1) -}
9dd25e46b76df9a6ad7069441e80bd3f
  $tcPuzzle1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Puzzle"#) -}
d6831ef04cb9301b090dfae6f7bb7ec7
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Main.$trModule2 Main.$trModule1) -}
847d9fc3b8e6f0b424199f36b4999bb2
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Main"#) -}
24ef6042833e75ffd7aa98b83ecca98d
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
b072c5b4f2e6962d9181829c10b44d97
  $w$cshow ::
    [GHC.Base.Maybe GHC.Types.Char]
    -> [GHC.Types.Char] -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: [GHC.Base.Maybe GHC.Types.Char])
                   (ww1 :: [GHC.Types.Char]) ->
                 case GHC.Base.map
                        @ (GHC.Base.Maybe GHC.Types.Char)
                        @ GHC.Types.Char
                        Main.renderPuzzleChar
                        ww of wild {
                   []
                   -> Main.$fShowPuzzle3
                        @ [GHC.Types.Char]
                        (GHC.Types.: @ GHC.Types.Char)
                        ww1
                   : x xs
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        (GHC.Types.:
                           @ GHC.Types.Char
                           x
                           (Data.OldList.prependToAll @ GHC.Types.Char Main.$fShowPuzzle2 xs))
                        (Main.$fShowPuzzle3
                           @ [GHC.Types.Char]
                           (GHC.Types.: @ GHC.Types.Char)
                           ww1) }) -}
3cdbd9db1757085ea587216da71fc26e
  $wgameOver ::
    GHC.Base.String
    -> [GHC.Types.Char]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,U><S,1*U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: [GHC.Types.Char])
                   (w :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.List.$wlenAcc @ GHC.Types.Char ww1 0# of ww2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># ww2 7#) of wild {
                   GHC.Types.False -> (# w, GHC.Tuple.() #)
                   GHC.Types.True
                   -> case GHC.IO.Handle.Text.hPutStr2
                             GHC.IO.Handle.FD.stdout
                             Main.gameOver2
                             GHC.Types.True
                             w of ds1 { (#,#) ipv ipv1 ->
                      case GHC.IO.Handle.Text.hPutStr2
                             GHC.IO.Handle.FD.stdout
                             (GHC.CString.unpackAppendCString# "The word was: "# ww)
                             GHC.Types.True
                             ipv of ds2 { (#,#) ipv2 ipv3 ->
                      System.Exit.exitSuccess1 @ () ipv2 } } } }) -}
e7bcaddbb9b9ffadacf725ce1ea0c05c
  $wgameWin ::
    [GHC.Base.Maybe GHC.Types.Char]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: [GHC.Base.Maybe GHC.Types.Char])
                   (w :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case (Main.gameWin_go ww) `cast` (Data.Monoid.N:All[0]) of wild {
                   GHC.Types.False -> (# w, GHC.Tuple.() #)
                   GHC.Types.True
                   -> case GHC.IO.Handle.Text.hPutStr2
                             GHC.IO.Handle.FD.stdout
                             Main.gameWin2
                             GHC.Types.True
                             w of ds1 { (#,#) ipv ipv1 ->
                      System.Exit.exitSuccess1 @ () ipv } }) -}
11d03a0d9e907dfb5d6c6bacab852180
  $wrunGame ::
    GHC.Base.String
    -> [GHC.Base.Maybe GHC.Types.Char]
    -> [GHC.Types.Char]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 4, Strictness: <L,U><L,U><S,U><S,U>, Inline: [0] -}
6045922ab9be9efcda54c9c5bf0b5016
  data Puzzle
    = Puzzle GHC.Base.String
             [GHC.Base.Maybe GHC.Types.Char]
             [GHC.Types.Char]
18e226540f1083ede38840e062bf7824
  type WordList = [GHC.Base.String]
e87eb27243d9cfe1ef5bf32c2f43d281
  allWords :: GHC.Types.IO Main.WordList
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.allWords1
                  `cast`
                (Sym (GHC.Types.N:IO[0] <Main.WordList>_R)) -}
c81c4834f90ed73f2d32f50bdfb097ca
  allWords1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Main.WordList #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.IO.Handle.FD.openFile1
                        Main.allWords2
                        GHC.IO.IOMode.ReadMode
                        s of ds1 { (#,#) ipv ipv2 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv2
                        ipv of ds2 { (#,#) ipv1 ipv3 ->
                 (# ipv1, Data.OldList.lines ipv3 #) } }) -}
2e893ff608e2343e1d9ca23fb20154fe
  allWords2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "data/dict.txt"#) -}
3fd54324ae2b7636d42c6f454351d7b5
  alreadyGuessed :: Main.Puzzle -> GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Main.Puzzle) (guessedCharacter :: GHC.Types.Char) ->
                 case ds of wild { Main.Puzzle ds1 ds2 alreadyGuessed1 ->
                 GHC.List.elem
                   @ GHC.Types.Char
                   GHC.Classes.$fEqChar
                   guessedCharacter
                   alreadyGuessed1 }) -}
018e8f05975f23ad8c931b0320c9f7ee
  bindRandomWords :: GHC.Types.IO GHC.Base.String
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.bindRandomWords1
                  `cast`
                (Sym (GHC.Types.N:IO[0] <GHC.Base.String>_R)) -}
a48a4f21c63738ed9b0a0eb70ee7f56d
  bindRandomWords1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Base.String #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case Main.bindRandomWords4 s of ds1 { (#,#) ipv ipv1 ->
                 Main.bindRandomWords2 ipv1 ipv }) -}
7a6de2156b1bf94255ca812a131c8cc3
  bindRandomWords2 ::
    Main.WordList
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Base.String #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (wordList :: Main.WordList)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case System.Random.$fRandomInt3
                        (Main.bindRandomWords3,
                         case GHC.List.$wlenAcc
                                @ [GHC.Types.Char]
                                wordList
                                0# of ww2 { DEFAULT ->
                         GHC.Types.I# (GHC.Prim.-# ww2 1#) })
                        s of ds1 { (#,#) ipv ipv1 ->
                 (# ipv, GHC.List.!! @ GHC.Base.String wordList ipv1 #) }) -}
bd0b341201be7b6f5c804f839109dffc
  bindRandomWords3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
dd0b4ce359a197a0762474edf75d14b6
  bindRandomWords4 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Main.WordList #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.IO.Handle.FD.openFile1
                        Main.allWords2
                        GHC.IO.IOMode.ReadMode
                        s of ds1 { (#,#) ipv ipv2 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv2
                        ipv of ds2 { (#,#) ipv1 ipv3 ->
                 (# ipv1,
                    GHC.List.filter
                      @ [GHC.Types.Char]
                      Main.bindRandomWords5
                      (Data.OldList.lines ipv3) #) } }) -}
adae2ea87c5f9be093c7141af0804fc1
  bindRandomWords5 :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ (w :: GHC.Base.String) ->
                 case GHC.List.$wlenAcc @ GHC.Types.Char w 0# of ww2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># ww2 5#) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww2 9#) } }) -}
5ff7f27f651ec786f0dd9cb3cbe801b8
  charInWord :: Main.Puzzle -> GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Main.Puzzle) (characterGuessed :: GHC.Types.Char) ->
                 case ds of wild { Main.Puzzle wordToGuess ds1 ds2 ->
                 GHC.List.elem
                   @ GHC.Types.Char
                   GHC.Classes.$fEqChar
                   characterGuessed
                   wordToGuess }) -}
8cc77a6b84503c5dd1d920dc50fa87e4
  fillInCharacter :: Main.Puzzle -> GHC.Types.Char -> Main.Puzzle
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U,1*U,U)><L,U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Main.Puzzle) (w1 :: GHC.Types.Char) ->
                 case w of ww { Main.Puzzle ww1 ww2 ww3 ->
                 Main.Puzzle
                   ww1
                   (GHC.List.zipWith
                      @ GHC.Types.Char
                      @ (GHC.Base.Maybe GHC.Types.Char)
                      @ (GHC.Base.Maybe GHC.Types.Char)
                      (\ (wordChar :: GHC.Types.Char)
                         (guessChar :: GHC.Base.Maybe GHC.Types.Char)[OneShot] ->
                       case wordChar of wild { GHC.Types.C# x ->
                       case w1 of wild1 { GHC.Types.C# y ->
                       case GHC.Prim.tagToEnum#
                              @ GHC.Types.Bool
                              (GHC.Prim.eqChar# x y) of wild2 {
                         GHC.Types.False -> guessChar
                         GHC.Types.True -> GHC.Base.Just @ GHC.Types.Char wild } } })
                      ww1
                      ww2)
                   (GHC.Types.: @ GHC.Types.Char w1 ww3) }) -}
6150405b0b37a9f552c9d6c95a62970f
  freshPuzzle :: GHC.Base.String -> Main.Puzzle
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (wordToGuess :: GHC.Base.String) ->
                 Main.Puzzle
                   wordToGuess
                   (GHC.Base.build
                      @ (GHC.Base.Maybe GHC.Types.Char)
                      (\ @ b1
                         (c :: GHC.Base.Maybe GHC.Types.Char -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ GHC.Types.Char
                         @ b1
                         (GHC.Base.mapFB
                            @ (GHC.Base.Maybe GHC.Types.Char)
                            @ b1
                            @ GHC.Types.Char
                            c
                            Main.freshPuzzle1)
                         n
                         wordToGuess))
                   (GHC.Types.[] @ GHC.Types.Char)) -}
239a9e7cc6b9ba0fd056adc5ff9d1e68
  freshPuzzle1 :: GHC.Types.Char -> GHC.Base.Maybe GHC.Types.Char
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (x :: GHC.Types.Char) -> GHC.Base.Nothing @ GHC.Types.Char) -}
aa4377c10bfabd0265aad43a8ddd6206
  gameOver :: Main.Puzzle -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <S(LLS),1*U(U,A,1*U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.gameOver1
                  `cast`
                (<Main.Puzzle>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
7c2e3e03466087c1ea559a0ba87be002
  gameOver1 ::
    Main.Puzzle
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S(LLS),1*U(U,A,1*U)><S,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Main.Puzzle)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case w of ww { Main.Puzzle ww1 ww2 ww3 ->
                 Main.$wgameOver ww1 ww3 w1 }) -}
8cd8fb928ff5e18bed2725c17c474a20
  gameOver2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "you lose"#) -}
41649bc108dbf490c586203c4bdeeab8
  gameWin :: Main.Puzzle -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <S(LSL),1*U(A,1*U,A)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.gameWin1
                  `cast`
                (<Main.Puzzle>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
1a371853753b705e5198e6a6b2bd2926
  gameWin1 ::
    Main.Puzzle
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S(LSL),1*U(A,1*U,A)><S,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Main.Puzzle)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case w of ww { Main.Puzzle ww1 ww2 ww3 ->
                 Main.$wgameWin ww2 w1 }) -}
339ecf04e8efdb1bc15fe47b0e5928ec
  gameWin2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "You win!"#) -}
54d7576698b92f3089932e82023ebbab
  gameWin_go :: [GHC.Base.Maybe GHC.Types.Char] -> Data.Monoid.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
6882bd8143ff97dff5873a15c34e11c5
  gameWords :: GHC.Types.IO Main.WordList
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.bindRandomWords4
                  `cast`
                (Sym (GHC.Types.N:IO[0] <Main.WordList>_R)) -}
1436f4dc8c9dafb84ebff5d8cc76c3af
  handleGuess ::
    Main.Puzzle -> GHC.Types.Char -> GHC.Types.IO Main.Puzzle
  {- Arity: 3, Strictness: <L,1*U(U,U,U)><L,U(U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.handleGuess1
                  `cast`
                (<Main.Puzzle>_R
                 ->_R <GHC.Types.Char>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Main.Puzzle>_R)) -}
4cf1cea3110c2538474278f43093965d
  handleGuess1 ::
    Main.Puzzle
    -> GHC.Types.Char
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Main.Puzzle #)
  {- Arity: 3, Strictness: <L,1*U(U,U,U)><L,U(U)><S,U>,
     Unfolding: (\ (puzzle :: Main.Puzzle)
                   (guess :: GHC.Types.Char)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        (GHC.CString.unpackAppendCString#
                           "Your guess was: "#
                           (GHC.Types.:
                              @ GHC.Types.Char
                              guess
                              (GHC.Types.[] @ GHC.Types.Char)))
                        GHC.Types.True
                        s of ds1 { (#,#) ipv ipv1 ->
                 case puzzle of wild { Main.Puzzle ds ds2 alreadyGuessed1 ->
                 case GHC.List.elem
                        @ GHC.Types.Char
                        GHC.Classes.$fEqChar
                        guess
                        alreadyGuessed1 of wild1 {
                   GHC.Types.False
                   -> case GHC.List.elem
                             @ GHC.Types.Char
                             GHC.Classes.$fEqChar
                             guess
                             ds of wild2 {
                        GHC.Types.False
                        -> case GHC.IO.Handle.Text.hPutStr2
                                  GHC.IO.Handle.FD.stdout
                                  Main.handleGuess4
                                  GHC.Types.True
                                  ipv of ds3 { (#,#) ipv2 ipv3 ->
                           (# ipv2,
                              Main.Puzzle
                                ds
                                (GHC.List.zipWith
                                   @ GHC.Types.Char
                                   @ (GHC.Base.Maybe GHC.Types.Char)
                                   @ (GHC.Base.Maybe GHC.Types.Char)
                                   (\ (wordChar :: GHC.Types.Char)
                                      (guessChar :: GHC.Base.Maybe GHC.Types.Char)[OneShot] ->
                                    case wordChar of wild3 { GHC.Types.C# x ->
                                    case guess of wild4 { GHC.Types.C# y ->
                                    case GHC.Prim.tagToEnum#
                                           @ GHC.Types.Bool
                                           (GHC.Prim.eqChar# x y) of wild5 {
                                      GHC.Types.False -> guessChar
                                      GHC.Types.True -> GHC.Base.Just @ GHC.Types.Char wild3 } } })
                                   ds
                                   ds2)
                                (GHC.Types.: @ GHC.Types.Char guess alreadyGuessed1) #) }
                        GHC.Types.True
                        -> case GHC.IO.Handle.Text.hPutStr2
                                  GHC.IO.Handle.FD.stdout
                                  Main.handleGuess3
                                  GHC.Types.True
                                  ipv of ds3 { (#,#) ipv2 ipv3 ->
                           (# ipv2,
                              Main.Puzzle
                                ds
                                (GHC.List.zipWith
                                   @ GHC.Types.Char
                                   @ (GHC.Base.Maybe GHC.Types.Char)
                                   @ (GHC.Base.Maybe GHC.Types.Char)
                                   (\ (wordChar :: GHC.Types.Char)
                                      (guessChar :: GHC.Base.Maybe GHC.Types.Char)[OneShot] ->
                                    case wordChar of wild3 { GHC.Types.C# x ->
                                    case guess of wild4 { GHC.Types.C# y ->
                                    case GHC.Prim.tagToEnum#
                                           @ GHC.Types.Bool
                                           (GHC.Prim.eqChar# x y) of wild5 {
                                      GHC.Types.False -> guessChar
                                      GHC.Types.True -> GHC.Base.Just @ GHC.Types.Char wild3 } } })
                                   ds
                                   ds2)
                                (GHC.Types.: @ GHC.Types.Char guess alreadyGuessed1) #) } }
                   GHC.Types.True
                   -> case GHC.IO.Handle.Text.hPutStr2
                             GHC.IO.Handle.FD.stdout
                             Main.handleGuess2
                             GHC.Types.True
                             ipv of ds3 { (#,#) ipv2 ipv3 ->
                      (# ipv2, wild #) } } } }) -}
5d39089b82d2d3549efb57472071db64
  handleGuess2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "You already guessed that character.  pick something else"#) -}
a55a557bceeb0e6a1d500080edf4d5f9
  handleGuess3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "This character was in the word.  Filling in the word accordingly"#) -}
f3bb08e4be7cfc62d8d27d3f30f1723e
  handleGuess4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "This character was not in the word. Try again"#) -}
2383dd2809eb6c8cf9d6f7c9fc71f069
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
3232f3b25c9c51ba850509209ccc507c
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.IO.Handle.FD.openFile1
                        Main.allWords2
                        GHC.IO.IOMode.ReadMode
                        s of ds1 { (#,#) ipv ipv2 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv2
                        ipv of ds2 { (#,#) ipv1 ipv3 ->
                 let {
                   ipv4 :: Main.WordList
                   = GHC.List.filter
                       @ [GHC.Types.Char]
                       Main.bindRandomWords5
                       (Data.OldList.lines ipv3)
                 } in
                 case System.Random.$fRandomInt3
                        (Main.bindRandomWords3,
                         case GHC.List.$wlenAcc
                                @ [GHC.Types.Char]
                                ipv4
                                0# of ww2 { DEFAULT ->
                         GHC.Types.I# (GHC.Prim.-# ww2 1#) })
                        ipv1 of ds3 { (#,#) ipv5 ipv6 ->
                 let {
                   wordToGuess :: GHC.Base.String
                   = case ipv6 of ww { GHC.Types.I# ww1 ->
                     GHC.Base.map
                       @ GHC.Types.Char
                       @ GHC.Types.Char
                       GHC.Unicode.toLower
                       (GHC.List.$w!! @ GHC.Base.String ipv4 ww1) }
                 } in
                 Main.$wrunGame
                   wordToGuess
                   (GHC.Base.map
                      @ GHC.Types.Char
                      @ (GHC.Base.Maybe GHC.Types.Char)
                      Main.freshPuzzle1
                      wordToGuess)
                   (GHC.Types.[] @ GHC.Types.Char)
                   ipv5 } } }) -}
6795901979bcd6582bee25799b42ff9c
  main2 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R))) -}
3f9c425a5ecce3112facb37f81ffbc8e
  maiximumWordLength :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 9#) -}
fe283617647f4eee0f09219a26fb1114
  mininumWordLength :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 5#) -}
ca51c51a907b4b13c38de80a1d1964fd
  randomWord :: Main.WordList -> GHC.Types.IO GHC.Base.String
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.bindRandomWords2
                  `cast`
                (<Main.WordList>_R
                 ->_R Sym (GHC.Types.N:IO[0] <GHC.Base.String>_R)) -}
ab91dc4d0d61b595f2fbfe46fe7a9244
  randomWord' :: GHC.Types.IO GHC.Base.String
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.bindRandomWords1
                  `cast`
                (Sym (GHC.Types.N:IO[0] <GHC.Base.String>_R)) -}
bf3245c50aded2b52f9d44d63a761a2c
  renderPuzzleChar :: GHC.Base.Maybe GHC.Types.Char -> GHC.Types.Char
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (maybeCharToShow :: GHC.Base.Maybe GHC.Types.Char) ->
                 case maybeCharToShow of wild {
                   GHC.Base.Nothing -> Main.renderPuzzleChar1
                   GHC.Base.Just ipv -> ipv }) -}
f1688679037fcea4db43809b03ad893a
  renderPuzzleChar1 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# '_'#) -}
14b82acdba65250466964590fe35dfa3
  runGame :: Main.Puzzle -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <S(LLS),U(U,U,U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.runGame1
                  `cast`
                (<Main.Puzzle>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
1df23f5ecd7c742f80833a7caced1e49
  runGame1 ::
    Main.Puzzle
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S(LLS),U(U,U,U)><S,U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Main.Puzzle)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case w of ww { Main.Puzzle ww1 ww2 ww3 ->
                 Main.$wrunGame ww1 ww2 ww3 w1 }) -}
instance [safe] GHC.Show.Show [Main.Puzzle] = Main.$fShowPuzzle
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

